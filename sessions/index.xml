<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sessions on Go Conference 2021 Autumn</title>
    <link>https://gocon.jp/2021autumn/sessions/</link>
    <description>Recent content in Sessions on Go Conference 2021 Autumn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language><atom:link href="https://gocon.jp/2021autumn/sessions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>(仮) Azure ADに完全対応した認証プロキシ・webサーバを開発してみた話</title>
      <link>https://gocon.jp/2021autumn/sessions/azure-ad-auth-server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/azure-ad-auth-server/</guid>
      <description>AzureにはApp ServiceやStatic Web Appsといったwebサイト構築に便利なPaaSがあり、Easy Authという組み込みの認証・認可機能を備えています。しかしながらエンタープライズ水準のきめ細かなアクセス制御が必要な場合は、開発者は依然として自分でその機能をwebアプリ中に組み込む必要がありました。今回、企業内webサイトのような、細かなアクセス制御の要件はあるがwebアプリにするまでもない静的webサイトを誰でも簡単に構築できることを目標として、Azure ADに対応した認証プロキシ・webサーバをGo言語で実装しましたので、実際の構築手順や事例と共に紹介します。</description>
    </item>
    
    <item>
      <title>After Party</title>
      <link>https://gocon.jp/2021autumn/sessions/after-party/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/after-party/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Break</title>
      <link>https://gocon.jp/2021autumn/sessions/_break/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/_break/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Closing</title>
      <link>https://gocon.jp/2021autumn/sessions/closing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/closing/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Cloud Gaming Platform with Go</title>
      <link>https://gocon.jp/2021autumn/sessions/go-cloud-gaming-platform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-cloud-gaming-platform/</guid>
      <description>私たちはクラウドゲーミングエンジンをフルスクラッチで開発し2021年に既存のエンジンを置き換えました。
そのバックエンドの大半はGoで開発しています。
クラウドゲーミングはまだ実例も少なく目新しい分野であり、実現のためには多種多様な技術が要求されます。
そんな中なぜGoを選んだのか、そしてGoの機能やライブラリがどのように既存プラットフォームの課題とクラウドゲーミング実現における課題を解決してくれたのかを技術分野ごとに解説します。
 Agenda  Introduction of Cloud Gaming Why Go? Go with Cloud Native Infrastructure  Containerization and Orchestration Build and Deploy   Go with Cloud Gaming  Live Streaming State Management Goroutines    </description>
    </item>
    
    <item>
      <title>Create Go WebDriver Client from Scratch</title>
      <link>https://gocon.jp/2021autumn/sessions/webdriver-client-from-scratch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/webdriver-client-from-scratch/</guid>
      <description>Webアプリ開発をしている現場ではUIレベルのブラウザ操作を自動化することによって実現する自動テストの作成は馴染みが深いものです。
ブラウザ操作の自動化にあたり出てくる WebDriver の Client はその仕様上 net/http パッケージ等の標準パッケージを介して自作することができます。
本トークでは、W3C勧告の標準化仕様WebDriver Wire Protocol等の詳細に軽く触れた上で、net/httpパッケージ等標準パッケージを組み合わせることでWebDriverとコミュニケーションをしブラウザを動かす実装方法を解説します。
 聴講者的な目線での期待設定としては、「WebDriverの仕様を理解して明日に活かす」と言うよりかは、「Goで実装するアイデアのバリエーションを増やす刺激になる」という後者を意識しています。
Goの特筆した点の一つは標準パッケージの機能性、それらの組み合わせてthird party packageを必須としなくても、自分のアイデアを実現できる点にあると考えます。WebDriverについてご存じの方であれば自明な話になるのですが、基本的にWebDriverはclient-serverの関係性でJSON HTTP APIがI/Fとなっています。ゆえに、本トークで紹介予定のWeb Driver clientについても多少のthird party packageを用いるかもしれませんが、主たる機能性については標準パッケージにて実装することになると想定しています。
多少WebDriverについての雑学を知りつつ、「このくらいブレークダウンすれば確かにGoで実装できるなぁ」的な&amp;quot;刺激&amp;quot;を、カンファレンスの締めの場になるLTにひと添えできればと思っております。</description>
    </item>
    
    <item>
      <title>Developing games in Go for Nintendo Switch™</title>
      <link>https://gocon.jp/2021autumn/sessions/go-nintendo-switch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-nintendo-switch/</guid>
      <description>Go を C++ に変換するツールを作成し、 Go で書かれたゲームを Nintendo Switch™ 上で動かすことに成功しました。本プレゼンテーションでは、 Go および Switch の制約、 Switch で動かすための手法や制作したツール、および今後の予定について説明します。
  自己紹介 (1 分) アジェンダ (1 分) Ebiten (2D ゲームライブラリ) (5 分)  機能 動作環境 作られたゲーム   Ebiten on Switch (5 分)  くまのレストランの紹介 Go for Nintendo Switch へのアクセス方法   やったこと (15-20 分)  Go の制約 Nintendo Switch の制約 その他の制約 手法の候補と選択 C++ コンバータ go2cpp go2cpp の仕組み   現状 (5 分)  パフォーマンス 実際に動かすための手順 今後の課題   まとめ (1 分)  </description>
    </item>
    
    <item>
      <title>Floating Point Numbers and Decimal in Go</title>
      <link>https://gocon.jp/2021autumn/sessions/go-floating-point-and-decimal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-floating-point-and-decimal/</guid>
      <description>プログラミングにおける小数の扱いは、注意が必要な定番のポイントだと思います。特に、精緻な計算が必要な処理では、桁落ちやオーバーフローを考慮することになります。
Goでは、組み込みの型の小数の挙動に少し独特な部分があります。また、精緻な計算を要求される場面では、math/bigパッケージなど、細かい小数を扱う仕組みも標準で提供されています。
そこでこのセッションでは、Goの組み込みの文法での小数の挙動を実際に見た上で、汎用的なアプローチとして、公式のmath/bigやサードパーティーのshopspring/decimalパッケージを利用した小数の取り扱い方法を紹介したいと思います。
 ゴール  Goの組み込みの文法の小数の挙動がわかること Goで小数を含む精緻な計算をする際に、注意すべき点や実際のアプローチ例がわかること  話す予定のトピック  プログラミングにおける小数 (前提確認) floatの小数の扱い untypedな定数の小数の扱い math/bigパッケージを使用した実装 shopspring/decimalパッケージを使用した実装  </description>
    </item>
    
    <item>
      <title>Go Contextを完全に理解する</title>
      <link>https://gocon.jp/2021autumn/sessions/understanding-go-context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/understanding-go-context/</guid>
      <description>Goではcontext.Contextを利用することで、キャンセルやタイムアウトを効率よく安全に実装することができます。
ContextはDBクライアントなど各種ライブラリを使う際に、対応する関数の引数にするだけでも動作します。
Contextはとても抽象度の高い存在ですが、実体はわずか数百行のコードで完結したライブラリです。
それだけの行数で動作するよう、非同期処理、インターフェースが高度に実装されています。
詳細な実装まで読み解いて、Contextをしっかりと理解してみたくなりませんか。
 Go Contextを完全に理解する 概要 Goではcontext.Contextを利用することで、キャンセルやタイムアウトを効率よく安全に実装することができます。
下記の３つのトピックで、Contextの概要から、詳細な仕組みまで、実際のcontext.Contextの実装を読み解きながら説明します。
context.Contextとは 初心者の方でも理解できるよう、contextがどのような目的で使われるかを説明します。
Contextの使い方 タイムアウト、キャンセル、任意の値のセット、取得といった方法を具体的に紹介します。
Contextが動作する仕組み context.Contextは抽象度の高さから想像できるイメージに反して、わずか数百行のコードで完結したライブラリです。
Contextの各種機能がどのように実装されているのか、コードリーディングして読み解いてみましょう。
対象 初心者〜上級者
言語 日本語(資料は英語にします)</description>
    </item>
    
    <item>
      <title>golang/mockでのモック生成と管理の &#34;より良い&#34; アプローチ</title>
      <link>https://gocon.jp/2021autumn/sessions/better-golang-mock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/better-golang-mock/</guid>
      <description>golang/mockというinterface定義からモックを生成するGoのツールがあります。
このLTではgolang/mockの生成と管理に特化したgomockhandlerというツールの紹介をします。
https://github.com/sanposhiho/gomockhandler
 コード生成を行うツールを導入する際、多くの場合で「(1)どのように生成するか」とその後「(2)生成したコードをどのように管理するか」の少なくとも二つの考慮点が増えることとなります。
1に関してはGoではgo generateが使用されることが多く、また、2に関してはGitHubで通常のコードと同時に管理されるのみとなる場合が多いです。
しかし、ツールによってはgo generateでコードを生成することが最適ではなかったり、「更新(= コードの生成し直し)忘れ」を防止する仕組みが必要となる場合があります。そして、一つ一つ順番にモックを生成する必要がなく、また、対象のinterfaceの更新のたびにモックを生成し直す必要があるgolang/mockはこの二つの点に当てはまります。
このLTでは gomockhandler というこれらの改善点を背景としたツールの紹介と、gomockhandler ではどのようにこれらの問題を解決しているかという内容の話をします。</description>
    </item>
    
    <item>
      <title>Golangで作るSQL Language Server(sqls)</title>
      <link>https://gocon.jp/2021autumn/sessions/golang-sqls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/golang-sqls/</guid>
      <description>私はGo言語でsqlsというSQL Language Serverを作りました。sqlsはSQLを静的解析し、DBから取得されたテーブルやカラム情報を組み合わせて、自動補完やドキュメント表示など、開発に必要なインテリセンスを提供するサーバーです。
利用するクライアントとの通信にLanguage Server Protocol(LSP)を用いることであらゆるエディタが、sqlsの支援を受けることができます。
 今回、私が語りたいのはsqlsの機能や、ユーザーがsqlsを利用して得られるメリットではなく、その製造プロセスです。
自分がカスタマイズしたエディタでSQLの自動補完を動かしたい。その熱意だけで、構文解析の手法を何一つ知らなかった私は多くの不明瞭な事柄に立ち向かいました。
 LSPの仕様とGo言語でのjson-rpc2サーバーの実装方法 自動補完のためのnon-validation parserとその実装方法 複数のデータベースへの対応 継続的開発のためのテストの整備  普段何気なく利用して私たちの開発体験を良くしてくれるツールですが、
創意工夫をすることで、自分でもこれを作ることもでき、充実した時間を得られるということを伝えたいと思います。
また、今回Go言語採用してsqlsを製造したことで、気づいたGo言語の利点などについても話します。</description>
    </item>
    
    <item>
      <title>Gormのバージョンを上げたお話</title>
      <link>https://gocon.jp/2021autumn/sessions/gorm-update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/gorm-update/</guid>
      <description>RettyではGo製のマイクロサービスでGORMを採用していますが、Version2リリースではいろいろなつまづきがあり苦労しました。
バージョンアップの過程での大変だったことや学んだことを共有します。
  Gormについて  簡単な紹介 v2アップデートの概要   v2アップデートで行ったこと  破壊的変更への対応 Rettyでの使われ方について   大変だったこと、ハマったこと、学んだこと  圧倒的物量 タグの使い方 パフォーマンスを出すために   これから取り組む方へのアドバイス  </description>
    </item>
    
    <item>
      <title>goroutineの仕組みについて</title>
      <link>https://gocon.jp/2021autumn/sessions/how-goroutine-works/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/how-goroutine-works/</guid>
      <description>私たちはgoというキーワードを用いることで、仕組みが分からずとも並行処理を容易に行うことができます。そこで、なぜGoではgoroutineにより効率的な並行処理を実現できているか説明します。
トークを通してgoroutineが既存のスレッドと異なりflyweightと呼ばれる理由を知ることができます。またgoroutineがどのように管理されているのかというスケジューラーの仕組みについても知ることができます。
そのため、ただgoroutineを使うというステップから、Goの言語的な仕組みを理解した上でgoroutineによる並行処理を用いることができるようになるでしょう。
 Goにはgoroutineという並行処理を実装するための手段が提供されています。
私たちは go というキーワードをプログラムで用いることでgoroutineを新たに作成し、並行処理をとても容易に実現することが可能です。
しかしgoroutineが他の並行(並列)処理とどの様な点で異なるのか、そしてgoroutineがどの様に並行処理を実現しているのかについて説明できる人はgoroutineを利用している人の人数に比べて多くはないでしょう。
そこで私のトークでは前半でgoroutineと他の並行(並列)処理について、後半でgoroutineがどの様に並行処理を実現しているかについてお話しします。対象者としてはGoの文法を理解し、ある程度開発経験がある上でGoの言語仕様を知りたい人です。
まず前半のパートについてです。初めに並行処理と並列処理の違いを説明します。この説明により、goroutineが並行処理と並列処理のどちらであるか定義した上で話すことができます。
説明する理由としては、goroutineを理解する上で並行と並列の違いを定義づけることがgoroutineの考え方を知るために必要であると考えているためです。
次にgoroutineとスレッドで行なっている並行(並列)処理がどの様に異なっているかについて話します。
内容としては以下の順に話します。
goroutineとスレッドの違い  メモリの使用量 生成と破棄のコストについて コンテキストスイッチについて  この説明を通してなぜgoroutineが軽量(flyweight)であると言われるのか理解することができます。
次に後半のパートについてです。goroutineが従来のスレッドと異なることを理解した上で、どの様にgoroutineが軽量スレッドによる並行処理を実現しているのかという仕組みをお話しします。goroutineは生成から破棄までGo独自のランタイムが管理しているため、goroutineを知るためにはGo独自のスケジューラーを理解する必要があります。スケジューラーの仕組みについては go/src/runtime/HACKING.md に書いています。
ところが実際に実装を見てみると G M P の様な見慣れない単語やM:Nモデルなどを理解する必要があります。
そこで後半では図を多く用いることで最終的にGoのランタイムを理解し、goroutineがどの様にGoによってスケジューリングされているかを理解することに役立てます。
前後半のトークを通して、聴いていただいた方達はgoroutineと他の並行(並列)処理との違いを理解した上で、goroutineを用いることができる様になります。
加えてGoのスケジューラーにも触れることで、ただGoを用いた開発をするというレベルから、なぜGoはこのような言語仕様になっているのかという今後のGoに対しての興味関心へと繋げてもらうことを目標としています。</description>
    </item>
    
    <item>
      <title>Goで超高速かつスケーラブルな逆ジオコーディングAPIサーバーを作ってみた</title>
      <link>https://gocon.jp/2021autumn/sessions/fast-scalable-reverse-geocoding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/fast-scalable-reverse-geocoding/</guid>
      <description>モビリティサービスでは緯度経度を住所に変換しなければならない場面が多々あります。SaaS APIでこの機能が提供されていますが、それらでは望む変換結果を得られない場面もあり、また、費用もそれなりにかかります。
そこで、外部SaaSに頼らずGolangを使って逆ジオコーディングAPIを自作することにしました。C言語で実装されたライブラリをCGO経由で活用しつつ、Go側の実装やデータの最適化を行うことで、usecオーダーで変換処理が完了する超高速なサービスを実現しました（APIの性能としてはHTTPのオーバーヘッドが支配的なレベルです）。
本セッションでは実装上工夫した点などを紹介します。
 株式会社Mobility Technologiesでは、タクシーアプリ『GO』や次世代AIドラレコサービス『DRIVE CHART』など、モビリティ領域においてサービスを展開していますが、そららすべてのサービスで求められる共通の機能がいくつか存在します。
その１つとして挙げられるのが、逆ジオコーディングと呼ばれる緯度経度情報から住所情報に変換する機能です。
利用シーンは様々ありますが、例えばタクシーアプリ『GO』ではアプリに表示された地図上でタクシーを呼びたい場所にピンを落とすと、その地点の住所が表示されますが、これも逆ジオコーディングの機能を利用しています。
この逆ジオコーディングの機能は、SaaS API等でも提供されており、弊社でもそれらを利用していました。
しかしながら、SaaSでは変換結果をカスタマイズすることができないため、我々の利用シーンに合わせた最適化を行うことができない点が課題でした。
また、我々のサービスにおける逆ジオコーディングの利用頻度を考えると、SaaS APIの利用料金は無視できないものとなっていました。
我々はサービスの別の機能で利用するために有償の地図データを契約しており、その地図データには逆ジオコーディングに必要なデータが含まれていました。
そこで、精度とコストの課題を解決するために、自作の逆ジオコーディングAPIを作ることにしました。
緯度経度から住所に変換するためには、まずその緯度経度がどの行政界（都道府県、市区町村、大字、町丁目などの行政区画）に属するかを判定しなければなりません。
これは例えば、国土交通省が公開している行政区域データに含まれる行政界ポリゴンの中に緯度経度が含まれているかどうかを判定することで実現できます。
このような計算はPoint-In-Polygonと呼ばれる、いわゆるGIS（Geographic Information System）系の処理なので、最近のRDBMSを利用すれば判定処理は実現できます。
しかしながら、GIS処理は逆ジオコーディングの処理中で負荷の中心部分となるため、RDBMSの機能を使って実現しようとするとRDBMSのスケーラビリティ性能に依存することになります。
もちろん、オートスケーリングとGISの両機能を持っているRDBMSもありますが、システムをシンプルかつハイパフォーマンスなものにするため、今回はRDBMSの機能を利用セず、
GISの処理もすべてGoで実装されたサーバー内で処理するようにしました。
具体的には、CGO経由でGDALと呼ばれるGISライブラリを利用することで実現しています。
逆ジオコーディングに利用できる住所と紐付いた行政界ポリゴンは、商用の地図データであれば〇〇町などの町名や１丁目などの丁目単位まで提供されるますが、
大量にあるポリゴンの中から指定された緯度経度を含むものを抽出する必要があります。
これを高速に行うためには、緯度経度で表される座標系を一定サイズの領域に空間分割し、分割された各領域にどの行政界ポリゴンが所属するのかを示すインデックスを事前計算によって構築しておく方法が考えられます。
空間分割の手段は様々なものが考えられますが、より高速かつデータ量が小さくなる手法を選択しました。
また、行政界ポリゴンについても階層化した形で持つことで、インデックスサイズがむやみに大きくならないようにしています。
緯度経度に対応する行政界ポリゴンが確定した後は、その行政界ポリゴンに含まれる住所情報の絞り込みを行います。
我々が利用している有償地図データには、ポイントデータとしてより詳細な住所情報が収録されており、これを利用することで緯度経度からより詳細な住所に変換することができます。
具体的には、住所に変換したい緯度経度に対して最も近い住所のポイントデータを抽出することができれば、答えに最も近い住所情報が得られることになります。
しかしながら全国の住所情報は数千万件規模になるため、すべての住所情報ポイントデータから最も近いものを抽出するのも工夫が必要となります。
我々は、最も詳細な行政界ポリゴン上に位置する住所情報ポイントデータを包含データとしてグルーピングし、
さらに行政界ポリゴン内においても空間分割で住所情報ポイントデータを領域ごとに分けて保持することで、
近傍の住所情報ポイントデータを検索する際に参照しなければならないデータ量を大幅に削減しました。
他にも緯度経度から住所情報に変換する際の精度向上のための工夫をいくつか入れていますが、
基本的にはアクセスするデータ量ができるだけ小さくなるようにしています。
インデックスだけでも1GB以上のサイズがあり、行政界ポリゴンや住所情報データのすべてをメモリにロードすると30GBにもなります。
問題なのは消費するメモリの量ではなく、データをロードするのに必要な時間です。
スケーラビリティを担保するためには素早くサーバーを起動し、サービスを提供できる状態にする必要があります。
スピンアップに何十分も掛けていてはリクエスト数が急激に増えた時に対応することができません。
十分なスケーラビリティを担保するために、我々はスピンアップ時に事前ロードしなければならないデータを極限まで減らし、
起動直後からリクエストを処理できるように工夫しました。もちろん、そのために起動直後の性能は多少犠牲にしましたが、
それでも性能はすぐに十分なレベルに到達可能です。
メンテナンス性とサーバーが必要とするスペック、実現可能な性能のバランスを取ることで、
十分なスケーラビリティ（アプリケーション側のスピンアップ時間は10秒）と高速性（HTTP応答速度は、50パーセンタイルで1ms以下、95パーセンタイルで10ms、99パーセンタイルで30ms）
を実現しながら、CPUやメモリなどのリソース使用状況は（利用状況にも依存しますが）一定水準で安定させることができています。
本セッションでは、上記の内容について実例を交えながら解説し、その中で用いているGo言語特有のテクニックも紹介します。</description>
    </item>
    
    <item>
      <title>Goで静的解析をはじめてみよう</title>
      <link>https://gocon.jp/2021autumn/sessions/go-static-analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-static-analysis/</guid>
      <description>静的解析を行うことで、プログラムの品質を高めることができます。Goでは golang.org/x/tools/go/analysis というパッケージを用いることによって、静的解析にあまりなじみがない開発者も、字句解析や構文解析を自前で実装せずに、静的解析モジュールを実装できます。
本LTでは、静的解析のモジュールを作った私の経験をもとに、静的解析のモジュール実装が身近なものであることをお伝えします。本LTのリスナーが静的解析のモジュールが実装できるんだ、と思ってもらえることをゴールとします。
 静的解析はプログラムのバグを早期に検出し、品質向上に寄与します。Goでは golang.org/x/tools/go/analysis パッケージを用いることで、構文解析や字句解析をモジュール開発者自身が実装することなく、静的解析で検出したいロジックに注力できます。
golang.org/x/tools/go/analysis パッケージを用いて静的解析モジュールを自作した経験から、Goで静的解析を始める方法をお伝えします。</description>
    </item>
    
    <item>
      <title>GoとGraphQLを使用したサービス開発</title>
      <link>https://gocon.jp/2021autumn/sessions/go-graphql-service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-graphql-service/</guid>
      <description>Rettyの新規事業Retty OrderはバックエンドにGoとGraphQLを採用し開発を行っています。
新規事業は刻々と状況が変わっていきます。ただ機能を開発するだけではなく、品質と速度の両立や今後の運用やスケールを見据えた開発を行っていく必要があります。
開発で工夫している点や採用技術など、どのように開発行っているのかご紹介します。
  Goの採用理由 Clean Architecture GraphQLでスキーマ駆動開発  99designs/gqlgenの知見  Redisを使用したSubscriptionの実装     テスト観点  それぞれのレイヤーでのテスト観点   工夫していること  Code generate(go-task) レプリカラグ  ローカルでは必ず1秒のレプリカラグを発生させている   データベースモデルの自動生成 Redisの負荷を減らす仕組み  アプリケーション内部のPub/Sub      </description>
    </item>
    
    <item>
      <title>GoのProposalの追い方ガイド</title>
      <link>https://gocon.jp/2021autumn/sessions/go-proposal-guide/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-proposal-guide/</guid>
      <description>Go projectにおいて、何か言語、ライブラリ、ツールへの重要な変更が行われる場合は、これに対して議論を行うためのデザインが必要となります。
この時、変更の提案元がGo Teamであろうと、外部からであろうと、同じプロセスを経ます。
このプロセスの初めに提出されるのが、Proposalです。
将来のGoがどうなっていくのか、短期的、長期的にキャッチアップをし続けたいのであれば、Proposalをウォッチするのは非常に有効な手段となります。
本発表では、ここ最近、Generics関連の動向を追いかけていく中で知ったProposalの追い方について、知っておくべき点をまとめて説明します。
 Goの最新動向を追うにあたって、Proposalへのキャッチアップは欠かせません。
Proposalは、誰でも簡単にGitHub Issueの形式でGo projectに対して提出することが出来ます。
その分、ウォッチするにあたっては、重要なProposalがどれかをある程度見分ける必要が出て来ます。
先日、Go 1.17 リリースパーティーにてGenerics関連のProposalの動向をまとめて以来、アップデートを追い続けているので、その経験の中から得られたProposalの追い方について説明します。
  GitHub Projectを使ったProposalのステージの運用 GitHub Issue / Discussion上で行われる議論内容の見方 『Proposing Changes to Go』に記載の重要事項  などについて説明を行います。</description>
    </item>
    
    <item>
      <title>Goの標準ライブラリで扱うフォントと画像</title>
      <link>https://gocon.jp/2021autumn/sessions/go-stdlib-font-image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-stdlib-font-image/</guid>
      <description>Goは一見不思議に思えるけどとても実践的なInterfaceを提供していると、私は考えています。net/http はその一例です。APIサーバーを書くソフトウェアエンジニアとして net/http には馴染みがあるのですが、ちょとした興味から触った image/draw や golang.org/x/image/font にも同じように一見不思議に見えるが実践的なInterfaceがあるなと感じました。その内容を、これらのパッケージを初めて見る方たちにも分かりやすいように実例を用いて説明します。最後には、Goの画像処理に興味を持った理由である自作Webサービスも紹介します。
  image  image と image/draw パッケージを利用した基礎的な画像操作  ource-over-destination と sourceという操作の説明 src/dst/mapという3つの概念と画像内位置情報をを利用することで、基礎的な画像操作を行う例を示す     font  基礎的な概念の説明  Font  「フォントとは正確にはグリフ集合とよばれる特定の文字セットと、特定の書体デザインにもとづく文字のかたちの集合である」   TrueType/OpenType  フォント配布形式 TrueTypeの上位互換であるOpenTypeという形式も存在する OpenTypeは「合字」「異体字の制御」「柔軟な文字詰め」等ができる Goは標準ライブラリを利用してTrueTypeとOpenType両方扱えるようになっている   Font File  フォントファイフ形式にのっとって作成されたファイル   Glyph  フォントの中の文字(字形)をグリフ(glyph)と呼ぶ 印刷やコンピュータ上で用いられる書体を、通常フォントと呼び、個々の字形をグリフ(Glyph)と呼ぶ     Glyphを描画する  imageの章で説明したsrc/dst/mapという3つの概念を利用し、1つGlyphを描画する  例示する   imageの章で説明したsrc/dst/mapという3つの概念を利用し、複数のGlyphを描画する  概念  https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyph_metrics_2x.png 重要な概念はadvancementとkern   x/image/font 内部の Drawer.</description>
    </item>
    
    <item>
      <title>io/fs.FS for testability. io/fs.FS for abstraction.</title>
      <link>https://gocon.jp/2021autumn/sessions/io-fs-fs-testability-abstraction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/io-fs-fs-testability-abstraction/</guid>
      <description>Go 1.16から追加されたio/fsパッケージが提供しているインターフェースについて、皆さんはどのような目的で活用していますか？
私は、主に2つの目的で活用しています。1つはテスト容易性（テスタビリティ）、もう1つはファイルシステムとしての抽象化です。
本発表では、具体的な事例を元に上記の2つの目的での使い方を紹介します。
また、fs.FSインターフェースを使ったことで失敗した事例も紹介したいと思います。
本発表を通じてio/fsのインターフェースの利用イメージを持ってもらえれば嬉しいです。
 Go 1.16から追加されたio/fsパッケージでは、fs.FSをはじめとしていくつかのインターフェースが提供されています。
全てはReadOnlyなメソッドのみで提供されており、一見すると使いどころが難しそうに見えます（少なくとも私には最初そう見えました）。
私は、主に2つの目的で活用しています。
1つはテスト容易性（テスタビリティ）のためです。ファイルシステムから読み込んで何かをする処理を、そのままOSのファイルシステムを使うのではなく、 fs.FS インターフェースを噛ませることで、テスト時には testing/fstest パッケージでスタブ化してテストが可能です。
もう1つはファイルシステムとしての抽象化です。これはLinuxにおける様々な要素のファイルシステムとしての抽象化（例えばprocfs）を知っていれば、想像がしやすいのではないでしょうか？
本発表では、上記2つの目的それぞれの用途における、io/fsパッケージのインターフェースの利用事例を紹介します。
また、io/fsパッケージが提供しているインターフェースを組み込んだことで失敗した事例も紹介します。
本発表を通じてio/fsのインターフェースの利用イメージを持ってもらえれば嬉しいです。</description>
    </item>
    
    <item>
      <title>io/fsパッケージを用いたテスタブルなコード生成ツールの開発</title>
      <link>https://gocon.jp/2021autumn/sessions/io-fs-testability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/io-fs-testability/</guid>
      <description>io/fsパッケージによりOSのファイルシステムに依存しない処理を書けます。例えば、複数のファイルを生成するツールの開発において、生成したファイル群をtxtar形式で出力し、ファイルシステムとして扱うことでテストを容易にできます。また、複数のファイルにまたがるテンプレートをtxtar形式として扱い、それをファイルシステムとして解釈することでtext/templateパッケージでパースでき、保守しやすさと可読性を両立できます。本セッションでは、skeletonという静的解析ツールのコードの雛形を生成するツールの開発で用いているio/fsパッケージを使ったいくつかの手法についてご紹介します。
 このセッションは以下のような構成で発表する予定です。
 [05min] コード生成とファイルシステムの抽象化 [15min] 保守しやすいコード生成 [15min] コード生成とゴールデンファイルテスト [05min] まとめ  [05min] コード生成とファイルシステムの抽象化 skeletonは静的解析ツールのコードの雛形を生成するコマンドラインツールです。ディレクトリに別れたいくつかのファイルを渡された入力を使って生成します。
現在のskeletonはv2です。v1における開発で直面したコード生成特有の課題とその問題をv2において改善するために用いた手法について概要を説明します。
[15min] 保守しやすいコード生成 skeletonのv1では自作ツールを使ってあるディレクトリ以下をtxtar形式に変換し、それをtext/templateパッケージを用いてテンプレートとしてパースしていました。テンプレートに入力されたデータを展開し、その結果を再度txtar形式として解釈し、ディレクトリやファイルを生成していました。
v2では、embedパッケージを用いてあるディレクトリ以下をファイルシステム（embed.FS）としてパッケージ変数に埋め込み、それをtxtar形式（txtarfs）として解釈しています。
ここでは、Goのコンパイラで用いられているtxtar形式やembedパッケージ、io/fsパッケージ、txtar形式にfs.FSインタフェースを実装させるtxtarfsパッケージなどの説明をv1とv2のコードを比較しながら説明します。
go.modファイルをembedパッケージで埋め込むちょっとしたTIPSなども紹介する予定です。
また、小さなコードを使ったデモも考えています。
[15min] コード生成とゴールデンファイルテスト v1ではテストが全くありませんでした。コマンドライン引数やオプションによって生成されるファイルが変わり、テストがしづらいことも理由の1つでした。
そこで、v2ではtxtarfsパッケージとゴールデンファイルテストを組み合わせることでコード生成と相性のよいテスト手法を編み出しました。
ここでは、コード生成ツールのテストのしづらさやゴールデンファイルテスト、txtarfsパッケージを使ったテストについて説明します。
ここでも小さなコードを使ったデモも考えています。
[05min] まとめ セッションをまとめます。
今後の展望なども話せるといいかなと思ってます。</description>
    </item>
    
    <item>
      <title>Learning Computer Systems by Crafting: Shell （作って学ぶシェル）</title>
      <link>https://gocon.jp/2021autumn/sessions/crafting-shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/crafting-shell/</guid>
      <description>We sometimes discuss newbies how to learn shell because it is like air. Let&amp;rsquo;s learn shell and computer systems by crafcting a subset of the POSIX shell via Go.
 There are few opportunities to learn shell explicitly. In these days, knowledge of the shell is more important to use modern technologies. For example, to create more portable/secure container images needs shell&amp;rsquo;s features like environment variables and more.
 Shell 101  What is a shell?</description>
    </item>
    
    <item>
      <title>Lunch</title>
      <link>https://gocon.jp/2021autumn/sessions/_lunch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/_lunch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>net/httpでつくるHTTPルーター自作入門</title>
      <link>https://gocon.jp/2021autumn/sessions/handmade-http-router/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/handmade-http-router/</guid>
      <description>Goの標準パッケージであるnet/httpを使ってHTTPルーターを自作する方法についてお話します。
net/httpを使った簡単なサーバーを起動するコードの読み解きから始めて、HTTPルーターの自作方法、アルゴリズムについて解説します。
優秀なルーターがOSSとして存在しているため、あまり自作するような機会はないかもしれませんが、自作を通して、net/httpや木構造への理解を深めることができます。
本LTはGoの入門者をターゲットとして、Goの理解につながるきっかけとなるような話になればと思っています。
 goblinという自作のHTTPルーターを作っています。
このルーターは、Goの標準パッケージだけで構成されており、net/httpのインターフェースとの互換性を保つように実装されています。
ルーターの自作を通して、私が学び得た知見についていくつかのブログ記事とスライドにまとめています。
 GolangのHTTPサーバーのコードリーディング URLルーティング自作入門　エピソード１ URLルーティング自作入門　エピソード２ Introduction to URL router from scratch with Golang GolangでURLルーターをつくった  本LTはこれらの内容を10分に総括したものとなります。</description>
    </item>
    
    <item>
      <title>Opening</title>
      <link>https://gocon.jp/2021autumn/sessions/opening/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/opening/</guid>
      <description>Opening talk.</description>
    </item>
    
    <item>
      <title>The use of goroutines and channels in the example of two-phase commit</title>
      <link>https://gocon.jp/2021autumn/sessions/two-phase-commit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/two-phase-commit/</guid>
      <description>Through actual examples of the use of goroutines and channels that I have encountered through my work, I will consider their general use.
To reduce the load on CloudSQL, we migrated some huge data to Datastore.
I will show the implementation of two-phase commit in the go language that I did.
 Through actual examples of the use of goroutines and channels that I have encountered through my work, I will consider their general use.</description>
    </item>
    
    <item>
      <title>TinyGo Workshop: A</title>
      <link>https://gocon.jp/2021autumn/sessions/workshop_a/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/workshop_a/</guid>
      <description>TBD</description>
    </item>
    
    <item>
      <title>TinyGo Workshop: B</title>
      <link>https://gocon.jp/2021autumn/sessions/workshop_b/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/workshop_b/</guid>
      <description>TBD</description>
    </item>
    
    <item>
      <title>Understanding the Go scheduling - Goにおけるスケジューリングの体系化(仮)</title>
      <link>https://gocon.jp/2021autumn/sessions/go-scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-scheduling/</guid>
      <description>Goにおいて複数のゴールーチンを並行に実行するためのスケジューラは、Goランタイム内で実装されています。しかし現在のスケジューラの大枠が実装されたのは9年前のGo1.1であり、世の中におけるGoのスケジューラ解説はそのときに世に出た公式設計書を元に、視覚的な図ベースで組み立てられているものがほとんどです。本セッションでは、スケジューラの挙動について実際のruntimeパッケージ内のコードベースで理解することを目的に、スケジューラについての説明体系を再構築します。
 このセッションで話さないこと 以下のことは今回は話題にはしません。
 並行処理って何？ ゴールーチンって何？ ゴールーチンを使って並行処理をうまく実装するにはどう書いたらいいの？  特に上2つに関しては、今回既知として扱わせていただきます。ご了承ください。
このセッションで話すこと・聞くとわかるようになること(予定)  runtimeパッケージって何やってるの？ Goのスケジューラってどういう指針でゴールーチンをスケジューリングしているの？ ゴールーチンのプリエンプトってどうやっているの？ システムコールを読んだとき・ネットワークI/Oに入ったときに、ランタイムはどういう処理をするの？ runtime・スケジューラの文脈でよく聞くG,M,Pって何？  主な対象者  Goで並行処理を書く人。特に「書いたゴールーチンがうまい具合に全部実行されるようスケジューリングされるのって不思議だな〜」と思っている人。 Goのスケジューラについて理解したい人。 システムプログラミングに興味がある人。 G,M,Pを使ってこれからGoのスケジューリングについて誰かに教えようとしている人。  課題と目的 Go言語には並行処理を行うための機構であるゴールーチンが存在し、そしてそれが複数存在する場合に「どのゴールーチンをスレッドに載せて実行させるか」をOSに頼らず決定するスケジューラーをGo独自の仕組みとして持っています。
現在のスケジューラの形が出来上がったのはGo1.1で、その公式設計書 - Scalable Go Scheduler Design Doc - において「GoのスケジューリングはG(goroutine),M(machine),P(Processor)という3つのリソースをうまく組み合わせることによって行う」という考え方が確立されました。
この設計書を元にMorsing&amp;rsquo;s Blog: The Go schedulerのようにG,M,Pの挙動を図にして表し説明する記事が数多く書かれ、様々な場合においてこれら3つの要素がどのような動きをするのかについて盛んに示されるようになりました。
しかし、これらの文脈において語られる概念が全てG,M,Pの中に収まっているのかというと、必ずしもそうではありません。
例えば、実行可能なゴールーチン(G)を保存しておく場所としてランタイム全体の「グローバルキュー」というものが存在しますが、これはruntimeパッケージ内ではG,M,Pとは別場所で実装されています。
また、Morsing&amp;rsquo;s Blog: The Go schedulerの記事を元に、Goのスケジューラの動きについて図を用いて語るウェブ記事やLTが数多く作られてきましたが、そのほとんどが図による説明のみで、それを実装しているコードがどこにあるのかについて示されているものはほとんどありません。
本セッションでは、Goのスケジューラを理解するために必要となる概念を過不足なく取り上げ、その挙動をruntimeパッケージ内の実装コードを明示しながら紐解いていくことを目的とします。
また、その過程において、Goのスケジューラをより明確に理解するための新しい切り口・体系のあり方について提案したいと思います。</description>
    </item>
    
    <item>
      <title>Write an embedded time-series database in Go</title>
      <link>https://gocon.jp/2021autumn/sessions/embedded-time-series-db/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/embedded-time-series-db/</guid>
      <description>Goプログラムからライブラリとして使える時系列データベースエンジンを作りました。他のタイプのデータベースと比べて扱うデータが遥かにシンプルである時系列データベースの実装方法を紹介することで、Go言語でデータベースエンジンを開発することが大変ではないことを聴衆に伝えます。
まず時系列データの特徴と解決するべき問題について簡単に触れ、現在時系列データベース界隈で主流となっているアプローチを紹介します。そして最後に、Go言語でどのように実装するかについて詳説します。
 必要に駆られ、Goプログラムからライブラリとして使える時系列データベースエンジンであるtstorageを作りました。これを実装するにあたってたくさんの課題に直面しました。例えば時系列データは一般的に、データ量が膨大になりがちです。それをどのように圧縮するのが効率的なのでしょうか？また、どのように局所性を高めるのが良いのでしょうか？
時系列データは扱うべき問題が比較的シンプルなので、要件次第では割り切った設計をすることが出来ます。そのため、データベースエンジンを初めて実装するには適した題材だと思います。
内容 まず時系列データの特徴と解決するべき問題について簡単に触れ、その対処方法について解説します。そして最後に、Go言語でどのように実装するかについて詳説します。
目的  シンプルなものであれば、Go言語でデータベースエンジンを自作することがそこまで大変ではないことを認知して頂く 先人達が考えた素晴らしいソリューションに感動して頂く  対象 前提知識は不要です。Go言語で何か作ることに興味がある方にとっては、何かの一助になるかもしれません。</description>
    </item>
    
    <item>
      <title>「🪦問題」から考えるGoのUnicodeサポート</title>
      <link>https://gocon.jp/2021autumn/sessions/go-unicode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/go-unicode/</guid>
      <description>SpannerとGoでサービス開発をしたときに、「🪦問題」に遭遇しました。
🪦が\U0001faa6になってしまった事象に遭遇したところから、Unicodeのリリースサイクルと、Goの追随状況、Unicodeサポート方法、spanner.NullStringを通してfmt.Sprintfの実装方法を調べました。
本セッションでは、調査した知見を共有することで、GoのUnicodeサポートについて少し詳しくなり、spanner.NullStringやfmt.SprintfとUnicodeのハマりどころを知ってもらえるセッションをお届けします。
  セッション形式  20分のセッション プレゼン資料と一部GolandでGoの実装コードやサンプルプログラムをデモします。   内容  GoのバージョンとUnicodeサポートによってテスト時に遭遇した🪦問題からUnicode/emojiとGoのサポート状況について詳細に調べました。  Unicodeは約1年に1回メジャーアップデートがされます。 それに合わせて、iOS/Androidも追随してアップデートで新しいemojiを追加しています。 Unicode/emojiのバージョンアップと、iOS/Androidがいつ追随しているのかを気にしたことがなかったのでいい機会なのでまとめました iOS/Androidが対応すると、当然それらのemojiをバックエンドのGoで受信するようになります。 GoのUnicodeサポートの追随状況はどうなっているのでしょうか。 追随できないとどういう問題があるのか、新しいGoバージョンを使う必要性が何故あるのかを見ます。   今回はSpannerを使用していて遭遇したので、spanner.NullStringの関連部分を紹介します fmt.SprintfでUnicode周りで問題が出る理由を見ていきます。   アジェンダ  Introduction 🪦問題とは 🪦問題が発生する前提条件 Unicodeとemojiのバージョンについて iOSとAndroidのemojiの追加追随状況 GolangのUnicodeサポートの追随状況 🪦問題が発生した原因 spanner.NullStringで問題が発生する原因 fmt.Sprintfで問題が発生する原因 GolangのUnicodeサポートの実装方法（Unicodeパッケージを深掘りしてみよう） 🪦問題を経て、リリースのために決断したこと まとめ    </description>
    </item>
    
    <item>
      <title>スポンサーセッション</title>
      <link>https://gocon.jp/2021autumn/sessions/sponsor-bitkey/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/sponsor-bitkey/</guid>
      <description></description>
    </item>
    
    <item>
      <title>スポンサーセッション</title>
      <link>https://gocon.jp/2021autumn/sessions/sponsor-dena/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/sponsor-dena/</guid>
      <description></description>
    </item>
    
    <item>
      <title>スポンサーセッション</title>
      <link>https://gocon.jp/2021autumn/sessions/sponsor-kaminashi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/sponsor-kaminashi/</guid>
      <description></description>
    </item>
    
    <item>
      <title>スポンサーセッション</title>
      <link>https://gocon.jp/2021autumn/sessions/sponsor-miidas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/sponsor-miidas/</guid>
      <description></description>
    </item>
    
    <item>
      <title>スポンサーセッション: Remo</title>
      <link>https://gocon.jp/2021autumn/sessions/sponsor-remo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/sponsor-remo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>マイクロサービス移行を仕上げる最後の数歩</title>
      <link>https://gocon.jp/2021autumn/sessions/microservice-last-steps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/microservice-last-steps/</guid>
      <description>Rettyではおよそ10年以上動いているPHPのモノリスから、Goベースのマイクロサービスへの移行を続けています。
長く開発が行われていましたが、2021年の3月から部分的に本番で運用されることになりました。
育ち過ぎたモノリスからGo製マイクロサービスへの移行、実用までの最後の仕上げについてご紹介します。
  マイクロサービス移行で描いた青写真・計画 マイクロサービス化はどこまで進んでいたか  モノリスの分割方法  育ち過ぎたモノリス、綺麗な分割は骨が折れる  バックエンドにロジック、フロントエンドにもロジック   まずはその密結合を分離する  モノリスの持っている情報をそのまま利用するサービスを作る     互換性の保ち方  protocol bufferの定義を入れたリポジトリを用意する     仕上げの話  移行対象を絞り、まずはミニマムな形を目指す 密結合は解消されたので、モノリスに依存したサービスを置き換えるようなサービスを作っていく いつでも分割できるようなモジュラモノリスが誕生  ファイルディスクリプタの枯渇という落とし穴      </description>
    </item>
    
    <item>
      <title>今日から使えるhttp.RoundTripper Tips</title>
      <link>https://gocon.jp/2021autumn/sessions/http-roundtripper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gocon.jp/2021autumn/sessions/http-roundtripper/</guid>
      <description>http.Clientを使ったコードを書くときにとっても便利なhttp.RoundTripperインタフェースについて、今日から使えるお役立ちTipsをご紹介します
  http.RoundTripperの役割 便利TIPS 3選  ロギング  リクエスト / レスポンス   リトライ  シンプルなリトライやExponential Backoff   モック  http.Clientの挙動を自由に変更      </description>
    </item>
    
  </channel>
</rss>
