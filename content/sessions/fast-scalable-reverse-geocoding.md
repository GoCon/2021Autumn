---
key: fast-scalable-reverse-geocoding
title: Goで超高速かつスケーラブルな逆ジオコーディングAPIサーバーを作ってみた
id: fast-scalable-reverse-geocoding
format: conference
talkType: ""
allroom: false
speakers:
- erakazu
---
モビリティサービスでは緯度経度を住所に変換しなければならない場面が多々あります。SaaS APIでこの機能が提供されていますが、それらでは望む変換結果を得られない場面もあり、また、費用もそれなりにかかります。
そこで、外部SaaSに頼らずGolangを使って逆ジオコーディングAPIを自作することにしました。C言語で実装されたライブラリをCGO経由で活用しつつ、Go側の実装やデータの最適化を行うことで、usecオーダーで変換処理が完了する超高速なサービスを実現しました（APIの性能としてはHTTPのオーバーヘッドが支配的なレベルです）。
本セッションでは実装上工夫した点などを紹介します。

---

株式会社Mobility Technologiesでは、タクシーアプリ『GO』や次世代AIドラレコサービス『DRIVE CHART』など、モビリティ領域においてサービスを展開していますが、そららすべてのサービスで求められる共通の機能がいくつか存在します。
その１つとして挙げられるのが、逆ジオコーディングと呼ばれる緯度経度情報から住所情報に変換する機能です。
利用シーンは様々ありますが、例えばタクシーアプリ『GO』ではアプリに表示された地図上でタクシーを呼びたい場所にピンを落とすと、その地点の住所が表示されますが、これも逆ジオコーディングの機能を利用しています。

この逆ジオコーディングの機能は、SaaS API等でも提供されており、弊社でもそれらを利用していました。
しかしながら、SaaSでは変換結果をカスタマイズすることができないため、我々の利用シーンに合わせた最適化を行うことができない点が課題でした。
また、我々のサービスにおける逆ジオコーディングの利用頻度を考えると、SaaS APIの利用料金は無視できないものとなっていました。
我々はサービスの別の機能で利用するために有償の地図データを契約しており、その地図データには逆ジオコーディングに必要なデータが含まれていました。
そこで、精度とコストの課題を解決するために、自作の逆ジオコーディングAPIを作ることにしました。

緯度経度から住所に変換するためには、まずその緯度経度がどの行政界（都道府県、市区町村、大字、町丁目などの行政区画）に属するかを判定しなければなりません。
これは例えば、国土交通省が公開している行政区域データに含まれる行政界ポリゴンの中に緯度経度が含まれているかどうかを判定することで実現できます。
このような計算はPoint-In-Polygonと呼ばれる、いわゆるGIS（Geographic Information System）系の処理なので、最近のRDBMSを利用すれば判定処理は実現できます。
しかしながら、GIS処理は逆ジオコーディングの処理中で負荷の中心部分となるため、RDBMSの機能を使って実現しようとするとRDBMSのスケーラビリティ性能に依存することになります。
もちろん、オートスケーリングとGISの両機能を持っているRDBMSもありますが、システムをシンプルかつハイパフォーマンスなものにするため、今回はRDBMSの機能を利用セず、
GISの処理もすべてGoで実装されたサーバー内で処理するようにしました。
具体的には、CGO経由でGDALと呼ばれるGISライブラリを利用することで実現しています。

逆ジオコーディングに利用できる住所と紐付いた行政界ポリゴンは、商用の地図データであれば〇〇町などの町名や１丁目などの丁目単位まで提供されるますが、
大量にあるポリゴンの中から指定された緯度経度を含むものを抽出する必要があります。
これを高速に行うためには、緯度経度で表される座標系を一定サイズの領域に空間分割し、分割された各領域にどの行政界ポリゴンが所属するのかを示すインデックスを事前計算によって構築しておく方法が考えられます。
空間分割の手段は様々なものが考えられますが、より高速かつデータ量が小さくなる手法を選択しました。
また、行政界ポリゴンについても階層化した形で持つことで、インデックスサイズがむやみに大きくならないようにしています。

緯度経度に対応する行政界ポリゴンが確定した後は、その行政界ポリゴンに含まれる住所情報の絞り込みを行います。
我々が利用している有償地図データには、ポイントデータとしてより詳細な住所情報が収録されており、これを利用することで緯度経度からより詳細な住所に変換することができます。
具体的には、住所に変換したい緯度経度に対して最も近い住所のポイントデータを抽出することができれば、答えに最も近い住所情報が得られることになります。
しかしながら全国の住所情報は数千万件規模になるため、すべての住所情報ポイントデータから最も近いものを抽出するのも工夫が必要となります。
我々は、最も詳細な行政界ポリゴン上に位置する住所情報ポイントデータを包含データとしてグルーピングし、
さらに行政界ポリゴン内においても空間分割で住所情報ポイントデータを領域ごとに分けて保持することで、
近傍の住所情報ポイントデータを検索する際に参照しなければならないデータ量を大幅に削減しました。

他にも緯度経度から住所情報に変換する際の精度向上のための工夫をいくつか入れていますが、
基本的にはアクセスするデータ量ができるだけ小さくなるようにしています。
インデックスだけでも1GB以上のサイズがあり、行政界ポリゴンや住所情報データのすべてをメモリにロードすると30GBにもなります。
問題なのは消費するメモリの量ではなく、データをロードするのに必要な時間です。
スケーラビリティを担保するためには素早くサーバーを起動し、サービスを提供できる状態にする必要があります。
スピンアップに何十分も掛けていてはリクエスト数が急激に増えた時に対応することができません。

十分なスケーラビリティを担保するために、我々はスピンアップ時に事前ロードしなければならないデータを極限まで減らし、
起動直後からリクエストを処理できるように工夫しました。もちろん、そのために起動直後の性能は多少犠牲にしましたが、
それでも性能はすぐに十分なレベルに到達可能です。
メンテナンス性とサーバーが必要とするスペック、実現可能な性能のバランスを取ることで、
十分なスケーラビリティ（アプリケーション側のスピンアップ時間は10秒）と高速性（HTTP応答速度は、50パーセンタイルで1ms以下、95パーセンタイルで10ms、99パーセンタイルで30ms）
を実現しながら、CPUやメモリなどのリソース使用状況は（利用状況にも依存しますが）一定水準で安定させることができています。

本セッションでは、上記の内容について実例を交えながら解説し、その中で用いているGo言語特有のテクニックも紹介します。
