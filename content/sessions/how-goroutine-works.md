---
key: how-goroutine-works
title: goroutineの仕組みについて
id: how-goroutine-works
format: conference
talkType: ""
allroom: false
speakers:
- sivchari
---
私たちはgoというキーワードを用いることで、仕組みが分からずとも並行処理を容易に行うことができます。そこで、なぜGoではgoroutineにより効率的な並行処理を実現できているか説明します。
トークを通してgoroutineが既存のスレッドと異なりflyweightと呼ばれる理由を知ることができます。またgoroutineがどのように管理されているのかというスケジューラーの仕組みについても知ることができます。
そのため、ただgoroutineを使うというステップから、Goの言語的な仕組みを理解した上でgoroutineによる並行処理を用いることができるようになるでしょう。

---

Goにはgoroutineという並行処理を実装するための手段が提供されています。
私たちは `go` というキーワードをプログラムで用いることでgoroutineを新たに作成し、並行処理をとても容易に実現することが可能です。
しかしgoroutineが他の並行(並列)処理とどの様な点で異なるのか、そしてgoroutineがどの様に並行処理を実現しているのかについて説明できる人はgoroutineを利用している人の人数に比べて多くはないでしょう。
そこで私のトークでは前半でgoroutineと他の並行(並列)処理について、後半でgoroutineがどの様に並行処理を実現しているかについてお話しします。対象者としてはGoの文法を理解し、ある程度開発経験がある上でGoの言語仕様を知りたい人です。

まず前半のパートについてです。初めに並行処理と並列処理の違いを説明します。この説明により、goroutineが並行処理と並列処理のどちらであるか定義した上で話すことができます。
説明する理由としては、goroutineを理解する上で並行と並列の違いを定義づけることがgoroutineの考え方を知るために必要であると考えているためです。
次にgoroutineとスレッドで行なっている並行(並列)処理がどの様に異なっているかについて話します。 
内容としては以下の順に話します。  

## goroutineとスレッドの違い

- メモリの使用量
- 生成と破棄のコストについて
- コンテキストスイッチについて

この説明を通してなぜgoroutineが軽量(flyweight)であると言われるのか理解することができます。

次に後半のパートについてです。goroutineが従来のスレッドと異なることを理解した上で、どの様にgoroutineが軽量スレッドによる並行処理を実現しているのかという仕組みをお話しします。goroutineは生成から破棄までGo独自のランタイムが管理しているため、goroutineを知るためにはGo独自のスケジューラーを理解する必要があります。スケジューラーの仕組みについては [go/src/runtime/HACKING.md](https://github.com/golang/go/blob/master/src/runtime/HACKING.md) に書いています。
ところが実際に実装を見てみると `G` `M` `P` の様な見慣れない単語やM:Nモデルなどを理解する必要があります。
そこで後半では図を多く用いることで最終的にGoのランタイムを理解し、goroutineがどの様にGoによってスケジューリングされているかを理解することに役立てます。

前後半のトークを通して、聴いていただいた方達はgoroutineと他の並行(並列)処理との違いを理解した上で、goroutineを用いることができる様になります。
加えてGoのスケジューラーにも触れることで、ただGoを用いた開発をするというレベルから、なぜGoはこのような言語仕様になっているのかという今後のGoに対しての興味関心へと繋げてもらうことを目標としています。
